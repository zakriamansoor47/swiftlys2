// <auto-generated />
#pragma warning disable CS0108
#nullable enable

using System;
using System.Threading;
using SwiftlyS2.Core.Schemas;
using SwiftlyS2.Shared.Schemas;
using SwiftlyS2.Shared.SchemaDefinitions;
using SwiftlyS2.Shared.Natives;
using SwiftlyS2.Core.Extensions;

namespace SwiftlyS2.Core.SchemaDefinitions;

internal partial class CPhysBoxImpl : CBreakableImpl, CPhysBox {

  public CPhysBoxImpl(nint handle) : base(handle) {
  }

  private static readonly Lazy<nint> _DamageTypeOffset = new(() => Schema.GetOffset(0x914B502B17488B28), LazyThreadSafetyMode.None);

  public ref int DamageType {
    get => ref _Handle.AsRef<int>(_DamageTypeOffset.Value);
  }
  private static readonly Lazy<nint> _DamageToEnableMotionOffset = new(() => Schema.GetOffset(0x914B502B6A217278), LazyThreadSafetyMode.None);

  public ref int DamageToEnableMotion {
    get => ref _Handle.AsRef<int>(_DamageToEnableMotionOffset.Value);
  }
  private static readonly Lazy<nint> _ForceToEnableMotionOffset = new(() => Schema.GetOffset(0x914B502B95BEED1A), LazyThreadSafetyMode.None);

  public ref float ForceToEnableMotion {
    get => ref _Handle.AsRef<float>(_ForceToEnableMotionOffset.Value);
  }
  private static readonly Lazy<nint> _HoverPosePositionOffset = new(() => Schema.GetOffset(0x914B502BE70418E3), LazyThreadSafetyMode.None);

  public ref Vector HoverPosePosition {
    get => ref _Handle.AsRef<Vector>(_HoverPosePositionOffset.Value);
  }
  private static readonly Lazy<nint> _HoverPoseAnglesOffset = new(() => Schema.GetOffset(0x914B502B086A1BC6), LazyThreadSafetyMode.None);

  public ref QAngle HoverPoseAngles {
    get => ref _Handle.AsRef<QAngle>(_HoverPoseAnglesOffset.Value);
  }
  private static readonly Lazy<nint> _NotSolidToWorldOffset = new(() => Schema.GetOffset(0x914B502B13A06DE8), LazyThreadSafetyMode.None);

  public ref bool NotSolidToWorld {
    get => ref _Handle.AsRef<bool>(_NotSolidToWorldOffset.Value);
  }
  private static readonly Lazy<nint> _EnableUseOutputOffset = new(() => Schema.GetOffset(0x914B502B2426C360), LazyThreadSafetyMode.None);

  public ref bool EnableUseOutput {
    get => ref _Handle.AsRef<bool>(_EnableUseOutputOffset.Value);
  }
  private static readonly Lazy<nint> _HoverPoseFlagsOffset = new(() => Schema.GetOffset(0x914B502BE0BEF17B), LazyThreadSafetyMode.None);

  public ref HoverPoseFlags_t HoverPoseFlags {
    get => ref _Handle.AsRef<HoverPoseFlags_t>(_HoverPoseFlagsOffset.Value);
  }
  private static readonly Lazy<nint> _TouchOutputPerEntityDelayOffset = new(() => Schema.GetOffset(0x914B502B0F1EF0C0), LazyThreadSafetyMode.None);

  public ref float TouchOutputPerEntityDelay {
    get => ref _Handle.AsRef<float>(_TouchOutputPerEntityDelayOffset.Value);
  }
  private static readonly Lazy<nint> _OnDamagedOffset = new(() => Schema.GetOffset(0x914B502B1667F41F), LazyThreadSafetyMode.None);

  public CEntityIOOutput OnDamaged {
    get => new CEntityIOOutputImpl(_Handle + _OnDamagedOffset.Value);
  }
  private static readonly Lazy<nint> _OnAwakenedOffset = new(() => Schema.GetOffset(0x914B502B03EDBB66), LazyThreadSafetyMode.None);

  public CEntityIOOutput OnAwakened {
    get => new CEntityIOOutputImpl(_Handle + _OnAwakenedOffset.Value);
  }
  private static readonly Lazy<nint> _OnMotionEnabledOffset = new(() => Schema.GetOffset(0x914B502BBB216C9F), LazyThreadSafetyMode.None);

  public CEntityIOOutput OnMotionEnabled {
    get => new CEntityIOOutputImpl(_Handle + _OnMotionEnabledOffset.Value);
  }
  private static readonly Lazy<nint> _OnPlayerUseOffset = new(() => Schema.GetOffset(0x914B502B611C9A14), LazyThreadSafetyMode.None);

  public CEntityIOOutput OnPlayerUse {
    get => new CEntityIOOutputImpl(_Handle + _OnPlayerUseOffset.Value);
  }
  private static readonly Lazy<nint> _OnStartTouchOffset = new(() => Schema.GetOffset(0x914B502BB4E38193), LazyThreadSafetyMode.None);

  public CEntityIOOutput OnStartTouch {
    get => new CEntityIOOutputImpl(_Handle + _OnStartTouchOffset.Value);
  }
  private static readonly Lazy<nint> _CarryingPlayerOffset = new(() => Schema.GetOffset(0x914B502B0491B86F), LazyThreadSafetyMode.None);

  public ref CHandle<CBasePlayerPawn> CarryingPlayer {
    get => ref _Handle.AsRef<CHandle<CBasePlayerPawn>>(_CarryingPlayerOffset.Value);
  }


}