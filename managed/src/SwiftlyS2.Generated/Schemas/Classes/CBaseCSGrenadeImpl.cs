// <auto-generated />
#pragma warning disable CS0108
#nullable enable

using System;
using System.Threading;
using SwiftlyS2.Core.Schemas;
using SwiftlyS2.Shared.Schemas;
using SwiftlyS2.Shared.SchemaDefinitions;
using SwiftlyS2.Shared.Natives;
using SwiftlyS2.Core.Extensions;

namespace SwiftlyS2.Core.SchemaDefinitions;

internal partial class CBaseCSGrenadeImpl : CCSWeaponBaseImpl, CBaseCSGrenade {

  public CBaseCSGrenadeImpl(nint handle) : base(handle) {
  }

  private static readonly Lazy<nint> _RedrawOffset = new(() => Schema.GetOffset(0x8680ADED612F4EB2), LazyThreadSafetyMode.None);

  public ref bool Redraw {
    get => ref _Handle.AsRef<bool>(_RedrawOffset.Value);
  }
  private static readonly Lazy<nint> _IsHeldByPlayerOffset = new(() => Schema.GetOffset(0x8680ADED5FB07B26), LazyThreadSafetyMode.None);

  public ref bool IsHeldByPlayer {
    get => ref _Handle.AsRef<bool>(_IsHeldByPlayerOffset.Value);
  }
  private static readonly Lazy<nint> _PinPulledOffset = new(() => Schema.GetOffset(0x8680ADEDB3D8AABA), LazyThreadSafetyMode.None);

  public ref bool PinPulled {
    get => ref _Handle.AsRef<bool>(_PinPulledOffset.Value);
  }
  private static readonly Lazy<nint> _JumpThrowOffset = new(() => Schema.GetOffset(0x8680ADED3202A7A7), LazyThreadSafetyMode.None);

  public ref bool JumpThrow {
    get => ref _Handle.AsRef<bool>(_JumpThrowOffset.Value);
  }
  private static readonly Lazy<nint> _ThrowAnimatingOffset = new(() => Schema.GetOffset(0x8680ADEDB2614685), LazyThreadSafetyMode.None);

  public ref bool ThrowAnimating {
    get => ref _Handle.AsRef<bool>(_ThrowAnimatingOffset.Value);
  }
  private static readonly Lazy<nint> _ThrowTimeOffset = new(() => Schema.GetOffset(0x8680ADED57C1B8DA), LazyThreadSafetyMode.None);

  public GameTime_t ThrowTime {
    get => new GameTime_tImpl(_Handle + _ThrowTimeOffset.Value);
  }
  private static readonly Lazy<nint> _ThrowStrengthOffset = new(() => Schema.GetOffset(0x8680ADEDF4D38CF4), LazyThreadSafetyMode.None);

  public ref float ThrowStrength {
    get => ref _Handle.AsRef<float>(_ThrowStrengthOffset.Value);
  }
  private static readonly Lazy<nint> _DropTimeOffset = new(() => Schema.GetOffset(0x8680ADED2DE88B09), LazyThreadSafetyMode.None);

  public GameTime_t DropTime {
    get => new GameTime_tImpl(_Handle + _DropTimeOffset.Value);
  }
  private static readonly Lazy<nint> _PinPullTimeOffset = new(() => Schema.GetOffset(0x8680ADEDFCD7B2E6), LazyThreadSafetyMode.None);

  public GameTime_t PinPullTime {
    get => new GameTime_tImpl(_Handle + _PinPullTimeOffset.Value);
  }
  private static readonly Lazy<nint> _JustPulledPinOffset = new(() => Schema.GetOffset(0x8680ADEDDA12F260), LazyThreadSafetyMode.None);

  public ref bool JustPulledPin {
    get => ref _Handle.AsRef<bool>(_JustPulledPinOffset.Value);
  }
  private static readonly Lazy<nint> _NextHoldTickOffset = new(() => Schema.GetOffset(0x8680ADEDDB254738), LazyThreadSafetyMode.None);

  public GameTick_t NextHoldTick {
    get => new GameTick_tImpl(_Handle + _NextHoldTickOffset.Value);
  }
  private static readonly Lazy<nint> _NextHoldFracOffset = new(() => Schema.GetOffset(0x8680ADED09F02BB7), LazyThreadSafetyMode.None);

  public ref float NextHoldFrac {
    get => ref _Handle.AsRef<float>(_NextHoldFracOffset.Value);
  }
  private static readonly Lazy<nint> _SwitchToWeaponAfterThrowOffset = new(() => Schema.GetOffset(0x8680ADED72CB2A60), LazyThreadSafetyMode.None);

  public ref CHandle<CCSWeaponBase> SwitchToWeaponAfterThrow {
    get => ref _Handle.AsRef<CHandle<CCSWeaponBase>>(_SwitchToWeaponAfterThrowOffset.Value);
  }

  public void RedrawUpdated() {
    Schema.Update(_Handle, 0x8680ADED612F4EB2);
  }
  public void IsHeldByPlayerUpdated() {
    Schema.Update(_Handle, 0x8680ADED5FB07B26);
  }
  public void PinPulledUpdated() {
    Schema.Update(_Handle, 0x8680ADEDB3D8AABA);
  }
  public void JumpThrowUpdated() {
    Schema.Update(_Handle, 0x8680ADED3202A7A7);
  }
  public void ThrowAnimatingUpdated() {
    Schema.Update(_Handle, 0x8680ADEDB2614685);
  }
  public void ThrowTimeUpdated() {
    Schema.Update(_Handle, 0x8680ADED57C1B8DA);
  }
  public void ThrowStrengthUpdated() {
    Schema.Update(_Handle, 0x8680ADEDF4D38CF4);
  }
  public void DropTimeUpdated() {
    Schema.Update(_Handle, 0x8680ADED2DE88B09);
  }
  public void PinPullTimeUpdated() {
    Schema.Update(_Handle, 0x8680ADEDFCD7B2E6);
  }
  public void JustPulledPinUpdated() {
    Schema.Update(_Handle, 0x8680ADEDDA12F260);
  }
  public void NextHoldTickUpdated() {
    Schema.Update(_Handle, 0x8680ADEDDB254738);
  }
  public void NextHoldFracUpdated() {
    Schema.Update(_Handle, 0x8680ADED09F02BB7);
  }
  public void SwitchToWeaponAfterThrowUpdated() {
    Schema.Update(_Handle, 0x8680ADED72CB2A60);
  }
}