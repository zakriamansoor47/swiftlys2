// <auto-generated />
#pragma warning disable CS0108
#nullable enable

using System;
using System.Threading;
using SwiftlyS2.Core.Schemas;
using SwiftlyS2.Shared.Schemas;
using SwiftlyS2.Shared.SchemaDefinitions;
using SwiftlyS2.Shared.Natives;
using SwiftlyS2.Core.Extensions;

namespace SwiftlyS2.Core.SchemaDefinitions;

internal partial class CTriggerPhysicsImpl : CBaseTriggerImpl, CTriggerPhysics {

  public CTriggerPhysicsImpl(nint handle) : base(handle) {
  }

  private static readonly Lazy<nint> _GravityScaleOffset = new(() => Schema.GetOffset(0xD6C7C8D3F22682F1), LazyThreadSafetyMode.None);

  public ref float GravityScale {
    get => ref _Handle.AsRef<float>(_GravityScaleOffset.Value);
  }
  private static readonly Lazy<nint> _LinearLimitOffset = new(() => Schema.GetOffset(0xD6C7C8D38455E743), LazyThreadSafetyMode.None);

  public ref float LinearLimit {
    get => ref _Handle.AsRef<float>(_LinearLimitOffset.Value);
  }
  private static readonly Lazy<nint> _LinearDampingOffset = new(() => Schema.GetOffset(0xD6C7C8D395E4E646), LazyThreadSafetyMode.None);

  public ref float LinearDamping {
    get => ref _Handle.AsRef<float>(_LinearDampingOffset.Value);
  }
  private static readonly Lazy<nint> _AngularLimitOffset = new(() => Schema.GetOffset(0xD6C7C8D3497B8D18), LazyThreadSafetyMode.None);

  public ref float AngularLimit {
    get => ref _Handle.AsRef<float>(_AngularLimitOffset.Value);
  }
  private static readonly Lazy<nint> _AngularDampingOffset = new(() => Schema.GetOffset(0xD6C7C8D36F1B9C61), LazyThreadSafetyMode.None);

  public ref float AngularDamping {
    get => ref _Handle.AsRef<float>(_AngularDampingOffset.Value);
  }
  private static readonly Lazy<nint> _LinearForceOffset = new(() => Schema.GetOffset(0xD6C7C8D32DAF4653), LazyThreadSafetyMode.None);

  public ref float LinearForce {
    get => ref _Handle.AsRef<float>(_LinearForceOffset.Value);
  }
  private static readonly Lazy<nint> _FrequencyOffset = new(() => Schema.GetOffset(0xD6C7C8D3D2C16DD7), LazyThreadSafetyMode.None);

  public ref float Frequency {
    get => ref _Handle.AsRef<float>(_FrequencyOffset.Value);
  }
  private static readonly Lazy<nint> _DampingRatioOffset = new(() => Schema.GetOffset(0xD6C7C8D3B40C859E), LazyThreadSafetyMode.None);

  public ref float DampingRatio {
    get => ref _Handle.AsRef<float>(_DampingRatioOffset.Value);
  }
  private static readonly Lazy<nint> _LinearForcePointAtOffset = new(() => Schema.GetOffset(0xD6C7C8D3C27DF46E), LazyThreadSafetyMode.None);

  public ref Vector LinearForcePointAt {
    get => ref _Handle.AsRef<Vector>(_LinearForcePointAtOffset.Value);
  }
  private static readonly Lazy<nint> _CollapseToForcePointOffset = new(() => Schema.GetOffset(0xD6C7C8D3EB895D00), LazyThreadSafetyMode.None);

  public ref bool CollapseToForcePoint {
    get => ref _Handle.AsRef<bool>(_CollapseToForcePointOffset.Value);
  }
  private static readonly Lazy<nint> _LinearForcePointAtWorldOffset = new(() => Schema.GetOffset(0xD6C7C8D3C80D3782), LazyThreadSafetyMode.None);

  public ref Vector LinearForcePointAtWorld {
    get => ref _Handle.AsRef<Vector>(_LinearForcePointAtWorldOffset.Value);
  }
  private static readonly Lazy<nint> _LinearForceDirectionOffset = new(() => Schema.GetOffset(0xD6C7C8D36076B2FC), LazyThreadSafetyMode.None);

  public ref Vector LinearForceDirection {
    get => ref _Handle.AsRef<Vector>(_LinearForceDirectionOffset.Value);
  }
  private static readonly Lazy<nint> _ConvertToDebrisWhenPossibleOffset = new(() => Schema.GetOffset(0xD6C7C8D36AD4D155), LazyThreadSafetyMode.None);

  public ref bool ConvertToDebrisWhenPossible {
    get => ref _Handle.AsRef<bool>(_ConvertToDebrisWhenPossibleOffset.Value);
  }

  public void GravityScaleUpdated() {
    Schema.Update(_Handle, 0xD6C7C8D3F22682F1);
  }
  public void LinearLimitUpdated() {
    Schema.Update(_Handle, 0xD6C7C8D38455E743);
  }
  public void LinearDampingUpdated() {
    Schema.Update(_Handle, 0xD6C7C8D395E4E646);
  }
  public void AngularLimitUpdated() {
    Schema.Update(_Handle, 0xD6C7C8D3497B8D18);
  }
  public void AngularDampingUpdated() {
    Schema.Update(_Handle, 0xD6C7C8D36F1B9C61);
  }
  public void LinearForceUpdated() {
    Schema.Update(_Handle, 0xD6C7C8D32DAF4653);
  }
  public void FrequencyUpdated() {
    Schema.Update(_Handle, 0xD6C7C8D3D2C16DD7);
  }
  public void DampingRatioUpdated() {
    Schema.Update(_Handle, 0xD6C7C8D3B40C859E);
  }
  public void LinearForcePointAtUpdated() {
    Schema.Update(_Handle, 0xD6C7C8D3C27DF46E);
  }
  public void CollapseToForcePointUpdated() {
    Schema.Update(_Handle, 0xD6C7C8D3EB895D00);
  }
  public void LinearForcePointAtWorldUpdated() {
    Schema.Update(_Handle, 0xD6C7C8D3C80D3782);
  }
  public void LinearForceDirectionUpdated() {
    Schema.Update(_Handle, 0xD6C7C8D36076B2FC);
  }
  public void ConvertToDebrisWhenPossibleUpdated() {
    Schema.Update(_Handle, 0xD6C7C8D36AD4D155);
  }
}